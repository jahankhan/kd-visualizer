!function(t){var e={};function i(h){if(e[h])return e[h].exports;var s=e[h]={i:h,l:!1,exports:{}};return t[h].call(s.exports,s,s.exports,i),s.l=!0,s.exports}i.m=t,i.c=e,i.d=function(t,e,h){i.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:h})},i.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=0)}([function(t,e,i){"use strict";i.r(e);var h=class{constructor(t,e){this.x=t,this.y=e}addVector(t){return this.x+=t[0],this.y+=t[1],this}divideVector(t){return this.x/=t,this.y/=t,this}};const s=25,a=2*Math.PI,r=-s/Math.sqrt(2),n=s/Math.sqrt(2),l=s/Math.sqrt(2),o=-60,d=60,c=40;var u=class{constructor(t){this.tree=t,this.ctx=document.getElementById("treeCanvas").getContext("2d")}drawTree(t){t&&(this.drawNode(t),t.leftChild&&window.setTimeout(()=>{this.drawTree(t.leftChild)},2e3),t.rightChild&&window.setTimeout(()=>{this.drawTree(t.rightChild)},3e3))}drawNode(t){this.ctx.beginPath(),this.ctx.arc(t.x,t.y,s,0,a,!0),this.ctx.textAlign="center",this.ctx.textBaseline="middle",this.ctx.fillStyle="#f7b983",this.ctx.fill(),this.ctx.fillStyle="#050200",this.ctx.fillText(t.data.join(","),t.x,t.y),this.ctx.stroke(),this.drawChildrenPath(t,this.ctx)}drawChildrenPath(t){null!==t.leftChild&&(this.ctx.beginPath(),this.ctx.moveTo(t.x+r,t.y+l),this.ctx.lineTo(t.x+o,t.y+c),this.ctx.stroke()),null!==t.rightChild&&(this.ctx.beginPath(),this.ctx.moveTo(t.x+n,t.y+l),this.ctx.lineTo(t.x+d,t.y+c),this.ctx.stroke())}};var g=class{constructor(t,e=null,i=null,s=null,a=0){this.data=t,this.parent=e,this.leftChild=i,this.rightChild=s,this.dim=a,this.x=150,this.y=100,this.velocity=new h(0,0)}addLeftChild(t){this.leftChild=t,t.parent=this,t.dim=(this.dim+1)%2,t.x=t.parent.x+o,t.y=t.parent.y+c}addRightChild(t){this.rightChild=t,t.parent=this,t.dim=(this.dim+1)%2,t.x=t.parent.x+d,t.y=t.parent.y+c}};var f=class{constructor(){this.heap=[]}leftChild(t){return 2*t+1}rightChild(t){return 2*t+2}parent(t){return Math.floor((t-1)/2)}peek(){return this.heap[0]}size(){return this.heap.length}insert(t){this.heap.push(t),this._heapifyUp()}extract(){let t=this.heap[0];this.heap[0]=this.heap[this.heap.length-1],this.heap[this.heap.length-1]=t;let e=this.heap.pop();return this._heapifyDown(),e}_heapifyUp(){let t=this.heap.length-1,e=this.parent(t);for(;e>=0&&this.heap[e]<this.heap[t];){let i=this.heap[t];this.heap[t]=this.heap[e],this.heap[e]=i,t=e,e=this.parent(e)}}_heapifyDown(){let t=0,e=this.leftChild(t),i=this.rightChild(t);for(;i<=this.heap.length-1;){let h=this.heap[e]>=this.heap[i]?e:i;if(!(this.heap[t]<this.heap[h]))break;{let s=this.heap[h];this.heap[h]=this.heap[t],this.heap[t]=s,t=h,e=this.leftChild(t),i=this.rightChild(t)}}}};const x=(t,e)=>t.sort((t,i)=>t[e]<i[e]?-1:t[e]===i[e]?0:1),p=(t,e)=>(t+1)%e;var C=class{constructor(t=null,e){this.root=t,this.dims=e}buildTree(t){t.forEach(t=>{this.assignPoint(t,this.root)})}setRoot(t){this.root=new g(t)}buildOptimalTree(t,e=0){if(0===t.length)return t;const i=x(t,e);let h,s;h=t.length%2==0?t[s=t.length/2-1]:t[s=Math.floor(t.length/2)],this.assignPoint(h,this.root);const a=i.slice(0,s),r=i.slice(s+1);this.buildOptimalTree(a,p(e,this.dims)),this.buildOptimalTree(r,p(e,this.dims))}assignPoint(t,e){if(!e)return this.setRoot(t);t[e.dim]<=e.data[e.dim]?null===e.leftChild?e.addLeftChild(new g(t)):this.assignPoint(t,e.leftChild):null===e.rightChild?e.addRightChild(new g(t)):this.assignPoint(t,e.rightChild)}rangeSearch(t,e){let i=[];if(t){if(t.data[0]>=e[0][0]&&t.data[0]<=e[0][1]&&t.data[1]>=e[1][0]&&t.data[1]<=e[1][1])return i.push(t),i=(i=i.concat(this.rangeSearch(t.leftChild,e))).concat(this.rangeSearch(t.rightChild,e));if(t.data[t.dim]>e[t.dim][1])return i=i.concat(this.rangeSearch(t.leftChild,e));if(t.data[t.dim]<e[t.dim][0])return i=i.concat(this.rangeSearch(t.rightChild,e))}return i}getPoints(t){let e=[];return t&&(e.push(t),e=(e=e.concat(this.getPoints(t.leftChild))).concat(this.getPoints(t.rightChild))),e}kNearestNeigborsNaive(t,e,i=1){const h=[[null,1e6]];for(let i=0;i<e.length;i++){let s=Math.sqrt((t[0]-e[i].data[0])**2+(t[1]-e[i].data[1])**2);console.log(s,e[i]),s<h[0][1]&&(h.shift(),h.unshift([e[i],s]))}return h}kNearestNeigbors(t,e,i,h=3,s={}){if(e){isNaN(e.data[0]);let a=this.euclideanDistance(t,e.data);if(console.log(a),i.size()<h)i.insert(a),s[a]=e,t[e.dim]<=e[e.dim]?(this.kNearestNeigbors(t,e.leftChild,i,h,s),this.kNearestNeigbors(t,e.rightChild,i,h,s)):(this.kNearestNeigbors(t,e.rightChild,i,h,s),this.kNearestNeigbors(t,e.leftChild,i,h,s));else{if(!(a<i.peek()))return i;s[a]=e,i.extract(),i.insert(a),this.kNearestNeigbors(t,e.leftChild,i,h,s),this.kNearestNeigbors(t,e.rightChild,i,h,s)}if(this.root===e){let t=[];for(let e=0;e<i.size();e++)t.push(s[i.heap[e]]);return t}return i}}euclideanDistance(t,e){let i=[];for(let h=0;h<t.length;h++)i.push((t[h]-e[h])**2);let h=i.reduce((t,e)=>t+e);return isNaN(Math.sqrt(h)),Math.sqrt(h)}centerOfMass(t){const e=this.kNearestNeigbors(t.data,this.root,new f,10);let i=null;for(let s=0;s<e.length;s++)t.data!==e[s].data&&(null===i?i=new h(e[s].data[0],e[s].data[1]):i.addVector(e[s].data));return i.divideVector(e.length-1),i.addVector(t.data).divideVector(100)}avoidCollision(t){let e=new h(0,0),i=this.getPoints(this.root);for(let h=0;h<i.length;h++)if(i[h].data!==t.data){let s=this.euclideanDistance(i[h].data,t.data);Math.abs(s)<100&&e.addVector(-s)}return e}matchVelocity(t){let e=null,i=this.kNearestNeigbors(t.data,this.root,new f,10);for(let t=0;t<i.length;t++)i[t].data!==i.data&&(null===e?e=new h(i[t].data[0],i[t].data[1]):e.addVector(i[t].velocity));return e.divideVector(i.length-1),e.addVector(t.velocity).divideVector(8)}bounding_box(t){let e=new h(0,0);return t.data[0]<0?e.x=10:t.data[0]>600?e.x=-10:t.data[1]<0?e.y=10:t.data[1]>0&&(e.y=-10),e}step(){let t,e,i,h,s=this.getPoints(this.root);for(let a=0;a<s.length;a++)t=this.centerOfMass(s[a]),e=this.avoidCollision(s[a]),i=this.matchVelocity(s[a]),h=this.bounding_box(s[a]),s[a].velocity.addVector(t).addVector(e).addVector(i).addVector(h),s[a].data[0]+=s[a].velocity.x,s[a].data[1]+=s[a].velocity.y}};var w=class{constructor(t){this.tree=t,this.ctx=document.getElementById("2DCanvas").getContext("2d"),this.width=620,this.height=620,this.ctx.beginPath(),this.ctx.strokeRect(0,0,600,600),this.drawAxis()}drawAxis(){for(let t=1;t<11;t++)this.ctx.beginPath(),this.ctx.textAlign="center",this.ctx.textBaseline="middle",this.ctx.fillText(t,60*t,610),this.ctx.fillText(t,610,600-60*t)}drawPoint(t){this.ctx.beginPath(),this.ctx.arc(60*t.data[0],600-60*t.data[1],4,0,a,!0),this.ctx.fill()}drawPartition(t){const e=this.getPathToRoot(t),{xBounds:i,yBounds:h}=this.findBoundaries(e);this.ctx.strokeRect(i[0],h[0],i[1]-i[0],h[1]-h[0])}getPathToRoot(t){const e=[t];if(t)for(;null!==t.parent;)e.push(t.parent),t=t.parent;return e.reverse()}findBoundaries(t){const e=[0,600],i=[0,600];for(let h=0;h<t.length;h++)t[h].leftChild===t[h+1]?0===t[h].dim?e[1]=60*t[h].data[0]:i[0]=600-60*t[h].data[1]:0===t[h].dim?e[0]=60*t[h].data[0]:i[1]=600-60*t[h].data[1];return{xBounds:e,yBounds:i}}drawVis(t){t&&(this.drawPoint(t),this.drawPartition(t),t.leftChild&&window.setTimeout(()=>{this.drawVis(t.leftChild)},2e3),t.rightChild&&window.setTimeout(()=>{this.drawVis(t.rightChild)},3e3))}};var m=class{constructor(t){this.tree=t,this.ctx=document.getElementById("boidCanvas").getContext("2d"),this.width=600,this.height=600,this.ctx.beginPath(),this.ctx.strokeRect(0,0,600,600),window.setInterval(()=>{console.log("going"),this.drawVis()},1e3)}drawVis(){let t=this.tree.getPoints(this.tree.root);for(let e=0;e<t.length;e++)this.drawPoint(t[e]);this.tree.step()}drawPoint(t){this.ctx.beginPath(),this.ctx.arc(t.data[0],600-t.data[1],2,0,a,!0),this.ctx.fill()}};document.addEventListener("DOMContentLoaded",()=>{const t=new C(null,2);t.buildOptimalTree([[8,1],[6,6],[2,6],[2,7],[9,8],[5,7],[5,6],[1,3],[4,2],[7,5],[12,7]]),console.log(t.getPoints(t.root)),new u(t).drawTree(t.root),new w(t).drawVis(t.root);new m(t)})}]);
//# sourceMappingURL=bundle.js.map