{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./scripts/heap.js","webpack:///./scripts/index.js","webpack:///./scripts/kd_node.js","webpack:///./scripts/kd_tree.js","webpack:///./scripts/three_d_vis.js","webpack:///./scripts/tree_util.js","webpack:///./scripts/tree_vis.js","webpack:///./scripts/two_d_vis.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACmB;AACwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;AC/C6C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;AC9BA;AACsC;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,yEAAyE;AACzE;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACvIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC;AACnF;AACA;;;AAGA;AACA,0EAA0E,kBAAkB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AC7DC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC,2CAA2C;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./scripts/index.js\");\n","class MaxHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  leftChild(i) {\n    return (2*i) + 1;\n  }\n\n  rightChild(i) {\n    return (2*i) + 2;\n  }\n\n  parent(i) {\n    return Math.floor((i-1)/2);\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  insert(el) {\n    this.heap.push(el);\n    this._heapifyUp();\n  }\n\n  extract() {\n    // let result = this.heap[0];\n    let temp = this.heap[0];\n    this.heap[0] = this.heap[this.heap.length-1];\n    this.heap[this.heap.length-1] = temp;\n    let result = this.heap.pop();\n    this._heapifyDown();\n    return result;\n  }\n\n  _heapifyUp() {\n    let child = this.heap.length-1;\n    let parent = this.parent(child);\n    while(parent >= 0) {\n      if(this.heap[parent] < this.heap[child]) {\n        let temp = this.heap[child];\n        this.heap[child] = this.heap[parent];\n        this.heap[parent] = temp;\n        child = parent;\n        parent = this.parent(parent);\n      } else {\n        break;\n      }\n    }\n  }\n\n  _heapifyDown() {\n    let parent = 0;\n    let leftChild = this.leftChild(parent);\n    let rightChild = this.rightChild(parent);\n    while(rightChild <= this.heap.length-1) {\n      let child = this.heap[leftChild] >= this.heap[rightChild] ? leftChild : rightChild;\n      if(this.heap[parent] < this.heap[child]) {\n        let temp = this.heap[child];\n        this.heap[child] = this.heap[parent];\n        this.heap[parent] = temp;\n        parent = child;\n        leftChild = this.leftChild(parent);\n        rightChild = this.rightChild(parent);\n      } else {\n        break;\n      }\n    }\n  }\n}\n\nexport default MaxHeap;\n","import KDTree from './kd_tree';\nimport KDNode from './kd_node';\nimport TreeVis from './tree_vis';\nimport TwoDVis from './two_d_vis';\nimport MaxHeap from './heap.js';\nimport { setScene } from './three_d_vis';\nimport { inorderTraversal, findAxisMedian } from './tree_util';\ndocument.addEventListener('DOMContentLoaded', () => {\n  const threedPointList = [\n    [8,1,1],\n    [6,6,2],\n    [2,6,4],\n    [2,7,1],\n    [9,8,8],\n    [5,7,1],\n    [5,6,3]\n  ];\n\n  const twodPointList = [\n    [8,1],\n    [6,6],\n    [2,6],\n    [2,7],\n    [9,8],\n    [5,7],\n    [5,6]\n  ];\n  // console.log(pointList);\n\n  const tree = new KDTree(null, 2);\n  tree.buildOptimalTree(twodPointList);\n  // console.log(tree);\n  const treeVis = new TreeVis(tree);\n  treeVis.drawTree(tree.root);\n  const twoDVis = new TwoDVis(tree);\n  twoDVis.drawVis(tree.root);\n  // setScene();\n  console.log(tree.rangeSearch(tree.root, [[2, 3], [5, 8]]));\n  console.log(tree.kNearestNeigborsNaive([2,5], tree.getPoints(tree.root)));\n  // const heap = new MaxHeap();\n  // heap.insert(1);\n  // heap.insert(5);\n  // heap.insert(3);\n  // heap.insert(9);\n  // heap.insert(11);\n  // heap.insert(7);\n  // heap.insert(2);\n});\n","import { LEFT_OFFSET, RIGHT_OFFSET, Y_OFFSET } from './tree_vis';\n\nclass KDNode {\n  constructor(data, parent = null, leftChild = null, rightChild = null, dim = 0) {\n    this.data = data;\n    this.parent = parent;\n    this.leftChild = leftChild;\n    this.rightChild = rightChild;\n    this.dim = dim;\n    this.x = 150;\n    this.y = 100;\n  }\n\n  addLeftChild(node) {\n    this.leftChild = node;\n    node.parent = this;\n    node.dim = (this.dim + 1) % 2;\n    node.x = node.parent.x + LEFT_OFFSET;\n    node.y = node.parent.y + Y_OFFSET;\n  }\n\n  addRightChild(node) {\n    this.rightChild = node;\n    node.parent = this;\n    node.dim = (this.dim + 1) % 2;\n    node.x = node.parent.x + RIGHT_OFFSET;\n    node.y = node.parent.y + Y_OFFSET;\n  }\n}\n\nexport default KDNode;\n","import KDNode from './kd_node';\nimport { sortByDimension, getNextDim } from './tree_util';\n\nclass KDTree {\n  constructor(root = null, dims) {\n    this.root = root;\n    this.dims = dims;\n  }\n\n  buildTree(pointList) {\n    pointList.forEach((point) => {\n      this.assignPoint(point, this.root);\n    });\n  }\n\n  setRoot(point) {\n    this.root = new KDNode(point);\n  }\n\n  buildOptimalTree(pointList, dim = 0) {\n    if(pointList.length === 0) {\n      return pointList;\n    }\n    // console.log(pointList);\n    const sortedList = sortByDimension(pointList, dim);\n\n    let pivot;\n    let mid;\n    if (pointList.length % 2 === 0) {\n      mid = (pointList.length/2)-1;\n      pivot = pointList[mid];\n    } else {\n      mid = Math.floor(pointList.length/2);\n      pivot = pointList[mid];\n    }\n    // console.log(pivot);\n    this.assignPoint(pivot, this.root);\n    const leftPointList = sortedList.slice(0, mid);\n    const rightPointList = sortedList.slice(mid+1);\n    this.buildOptimalTree(leftPointList, getNextDim(dim, this.dims));\n    this.buildOptimalTree(rightPointList, getNextDim(dim, this.dims));\n  }\n\n  assignPoint(point, node) {\n    if (!node) {\n      return this.setRoot(point);\n    }\n    if(point[node.dim] <= node.data[node.dim]) {\n      if(node.leftChild === null){\n        node.addLeftChild(new KDNode(point));\n      } else {\n        this.assignPoint(point, node.leftChild);\n      }\n    } else {\n      // debugger\n      if(node.rightChild === null) {\n        node.addRightChild(new KDNode(point));\n      } else {\n        this.assignPoint(point, node.rightChild);\n      }\n    }\n  }\n\n  rangeSearch(node, bounds) {\n    let nodeList = [];\n    // debugger\n    if(node) {\n      if(node.data[0] >= bounds[0][0] && node.data[0] <= bounds[0][1] &&\n          node.data[1] >= bounds[1][0] && node.data[1] <= bounds[1][1]) {\n        nodeList.push(node);\n        nodeList = nodeList.concat(this.rangeSearch(node.leftChild, bounds));\n        nodeList = nodeList.concat(this.rangeSearch(node.rightChild, bounds));\n        return nodeList;\n      } else {\n        if(node.data[node.dim] > bounds[node.dim][1]) {\n          nodeList = nodeList.concat(this.rangeSearch(node.leftChild, bounds));\n          return nodeList;\n        } else if(node.data[node.dim] < bounds[node.dim][0]) {\n          nodeList = nodeList.concat(this.rangeSearch(node.rightChild, bounds));\n          return nodeList;\n        }\n      }\n    }\n    return nodeList;\n  }\n\n  getPoints(node) {\n    let points = [];\n    if (node) {\n      points.push(node);\n      points = points.concat(this.getPoints(node.leftChild));\n      points = points.concat(this.getPoints(node.rightChild));\n    }\n    return points;\n  }\n\n  kNearestNeigborsNaive(queryPoint, points, k=1) {\n    const champions = [[null, 1000000]];\n\n    for(let i = 0; i < points.length; i++) {\n      let distance = Math.sqrt((queryPoint[0] - points[i].data[0])**2 + (queryPoint[1] - points[i].data[1])**2);\n      console.log(distance, points[i]);\n      if(distance < champions[0][1]) {\n        champions.shift();\n        champions.unshift([points[i], distance]);\n      }\n    }\n    return champions;\n  }\n\n  // kNearestNeigbors(queryPoint, node, champions = [], k=1) {\n  //   if (node) {\n  //     let distance = this.euclideanDistance(queryPoint, node);\n  //     if(champions.length < k) {\n  //       champions.push([node, distance]);\n  //     } else {\n  //       if(distance < champions[0][1]) {\n  //\n  //       }\n  //     }\n  //   }\n  //\n  //\n  // }\n\n  euclideanDistance(pointA, pointB) {\n    let dimValues = [];\n    for(let i = 0; i < pointA.length; i++) {\n      dimValues.push((pointA[i] - pointB[i])**2);\n    }\n    // return Math.sqrt(dimValues.reduce((acc, currVal) => acc + currVal;));\n    return 5;\n  }\n}\n\nexport default KDTree;\n","export const setScene = () => {\n  const scene = new THREE.Scene();\n  const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\n\n  const renderer = new THREE.WebGLRenderer();\n  renderer.setSize( window.innerWidth, window.innerHeight );\n  document.body.appendChild( renderer.domElement );\n  const geometry = new THREE.BoxBufferGeometry( 5, 5, 1 );\n  const material = new THREE.MeshBasicMaterial( { transparent: true, opacity: 0.5 } );\n  const cube = new THREE.Mesh( geometry, material );\n  scene.add( cube );\n\n\n  var edges = new THREE.EdgesGeometry( geometry );\n  var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );\n  scene.add( line );\n  camera.position.z = 5;\n  function animate() {\n  \trequestAnimationFrame( animate );\n    cube.rotation.x += 0.01;\n    cube.rotation.y += 0.01;\n    // edges.rotation.x += .01;\n    // geometry.rotation.x += .01;\n  \trenderer.render( scene, camera );\n  }\n  animate();\n}\n","export const inorderTraversal = root => {\n\n  if(root.leftChild !== null) {\n    inorderTraversal(root.leftChild);\n  }\n  // console.log(root);\n  if(root.rightChild !== null) {\n    inorderTraversal(root.rightChild);\n  }\n  return;\n};\n\nexport const sortByDimension = (list, dim) => {\n  return list.sort((pointA, pointB) => {\n    if(pointA[dim] < pointB[dim]) {\n      return -1;\n    } else if (pointA[dim] === pointB[dim]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  });\n  // if (list.length % 2 === 0) {\n  //   return list[(list.length/2)-1];\n  // } else {\n  //   return list[Math.floor(list.length/2)];\n  // }\n};\n\nexport const getNextDim = (dim, totalDims) => {\n  return (dim + 1) % totalDims;\n};\n","export const NODE_RADIUS = 25;\nexport const FULL_CIRCLE = Math.PI * 2;\nexport const LEFT_START = -(NODE_RADIUS/Math.sqrt(2));\nexport const RIGHT_START = (NODE_RADIUS/Math.sqrt(2));\nexport const Y_START = (NODE_RADIUS/Math.sqrt(2));\nexport const LEFT_OFFSET = -40;\nexport const RIGHT_OFFSET = 40;\nexport const Y_OFFSET = 50;\nexport const X = 600;\nexport const Y = 600;\n\nclass TreeVis {\n  constructor(tree) {\n    this.tree = tree;\n    this.ctx = document.getElementById(\"treeCanvas\").getContext(\"2d\");\n  }\n\n  drawTree(node) {\n    if(node) {\n      this.drawNode(node);\n      if(node.leftChild) {\n        window.setTimeout(() => {\n          this.drawTree(node.leftChild);\n        }, 2000);\n      }\n      if (node.rightChild) {\n        window.setTimeout(() => {\n          this.drawTree(node.rightChild);\n        }, 3000);\n      }\n    }\n    return ;\n  }\n\n  drawNode(node) {\n    this.ctx.beginPath();\n    this.ctx.arc(node.x, node.y, NODE_RADIUS, 0, FULL_CIRCLE, true);\n    this.ctx.textAlign = \"center\";\n    this.ctx.textBaseline = \"middle\";\n    this.ctx.fillStyle = \"#f7b983\";\n    this.ctx.fill();\n    this.ctx.fillStyle = \"#050200\";\n    this.ctx.fillText(node.data.join(','), node.x, node.y);\n    this.ctx.stroke();\n    this.drawChildrenPath(node, this.ctx);\n  }\n\n  drawChildrenPath(node) {\n    if(node.leftChild !== null) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(node.x + LEFT_START, node.y + Y_START);\n      this.ctx.lineTo(node.x+ LEFT_OFFSET, node.y + Y_OFFSET);\n      this.ctx.stroke();\n    }\n    if(node.rightChild !== null) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(node.x+ RIGHT_START, node.y + Y_START);\n      this.ctx.lineTo(node.x+ RIGHT_OFFSET, node.y + Y_OFFSET);\n      this.ctx.stroke();\n    }\n  }\n}\n\nexport default TreeVis;\n","import {\n  FULL_CIRCLE\n} from './tree_vis';\n\nclass TwoDVis {\n  constructor(tree) {\n    this.tree = tree;\n    this.ctx = document.getElementById(\"2DCanvas\").getContext(\"2d\");\n    this.width = 620;\n    this.height = 620;\n    this.ctx.beginPath();\n    this.ctx.strokeRect(0, 0, 600, 600);\n    this.drawAxis();\n  }\n\n  drawAxis() {\n    for(let i = 1; i < 11; i++) {\n      this.ctx.beginPath();\n      // this.ctx.moveTo(i*60, 610);\n      // this.ctx.stroke();\n      this.ctx.textAlign = \"center\";\n      this.ctx.textBaseline = \"middle\";\n      this.ctx.fillText(i, i*60, 610);\n      this.ctx.fillText(i, 610, 600- i*60);\n    }\n  }\n\n  drawPoint(node) {\n    this.ctx.beginPath();\n    this.ctx.arc(node.data[0]*60, 600 - node.data[1]*60, 4, 0, FULL_CIRCLE, true);\n    this.ctx.fill();\n  }\n\n  drawPartition(node) {\n    const path = this.getPathToRoot(node);\n    const { xBounds, yBounds } = this.findBoundaries(path);\n    this.ctx.strokeRect(xBounds[0], yBounds[0], xBounds[1]-xBounds[0], yBounds[1]-yBounds[0]);\n  }\n\n  getPathToRoot(node) {\n    const path = [node];\n    if(node) {\n      while(node.parent !== null) {\n        path.push(node.parent)\n        node = node.parent;\n      }\n    }\n    return path.reverse();\n  }\n\n  findBoundaries(path) {\n    const xBounds = [0, 600];\n    const yBounds = [0, 600];\n    for(let i = 0; i < path.length; i++) {\n      if(path[i].leftChild === path[i+1]) { //left child\n        if(path[i].dim === 0) {\n          xBounds[1] = path[i].data[0] * 60;\n        } else {\n          yBounds[0] = 600 - path[i].data[1] * 60;\n        }\n      } else { //right child\n        if(path[i].dim === 0) {\n          xBounds[0] = path[i].data[0] * 60;\n        } else {\n          yBounds[1] = 600 - path[i].data[1] * 60;\n        }\n      }\n    }\n    return { xBounds,yBounds };\n  }\n\n  drawVis(node) {\n    if(node) {\n      this.drawPoint(node);\n      this.drawPartition(node);\n      if(node.leftChild) {\n        window.setTimeout(() => {\n          this.drawVis(node.leftChild);\n        }, 2000);\n      }\n      if (node.rightChild) {\n        window.setTimeout(() => {\n          this.drawVis(node.rightChild);\n        }, 3000);\n      }\n    }\n  }\n}\n\nexport default TwoDVis;\n"],"sourceRoot":""}