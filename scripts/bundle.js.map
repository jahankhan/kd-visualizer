{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./scripts/vector.js","webpack:///./scripts/tree_vis.js","webpack:///./scripts/kd_node.js","webpack:///./scripts/heap.js","webpack:///./scripts/tree_util.js","webpack:///./scripts/kd_tree.js","webpack:///./scripts/two_d_vis.js","webpack:///./scripts/boid_vis.js","webpack:///./scripts/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","scripts_vector","[object Object]","x","y","this","vector","constant","NODE_RADIUS","FULL_CIRCLE","Math","PI","LEFT_START","sqrt","RIGHT_START","Y_START","LEFT_OFFSET","RIGHT_OFFSET","Y_OFFSET","tree_vis","tree","ctx","document","getElementById","getContext","node","drawNode","leftChild","window","setTimeout","drawTree","rightChild","beginPath","arc","textAlign","textBaseline","fillStyle","fill","fillText","data","join","stroke","drawChildrenPath","moveTo","lineTo","kd_node","parent","dim","velocity","heap","floor","length","el","push","_heapifyUp","temp","result","pop","_heapifyDown","child","sortByDimension","list","sort","pointA","pointB","getNextDim","totalDims","kd_tree","root","dims","pointList","forEach","point","assignPoint","sortedList","pivot","mid","leftPointList","slice","rightPointList","buildOptimalTree","setRoot","addLeftChild","addRightChild","bounds","nodeList","concat","rangeSearch","points","getPoints","queryPoint","k","champions","distance","console","log","shift","unshift","hash","isNaN","euclideanDistance","size","insert","kNearestNeigbors","peek","extract","results","dimValues","sum","reduce","acc","currVal","nodes","cOfMass","addVector","divideVector","abs","v1","v2","v3","v4","centerOfMass","avoidCollision","matchVelocity","bounding_box","two_d_vis","width","height","strokeRect","drawAxis","path","getPathToRoot","xBounds","yBounds","findBoundaries","reverse","drawPoint","drawPartition","drawVis","boid_vis","setInterval","step","addEventListener"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","class TwoDVector {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  addVector(vector) {\n    this.x += vector[0];\n    this.y += vector[1];\n    return this;\n  }\n\n  divideVector(constant) {\n    this.x /= constant;\n    this.y /= constant;\n    return this;\n  }\n}\n\nexport default TwoDVector;\n","export const NODE_RADIUS = 25;\nexport const FULL_CIRCLE = Math.PI * 2;\nexport const LEFT_START = -(NODE_RADIUS/Math.sqrt(2));\nexport const RIGHT_START = (NODE_RADIUS/Math.sqrt(2));\nexport const Y_START = (NODE_RADIUS/Math.sqrt(2));\nexport const LEFT_OFFSET = -60;\nexport const RIGHT_OFFSET = 60;\nexport const Y_OFFSET = 40;\nexport const X = 600;\nexport const Y = 600;\n\nclass TreeVis {\n  constructor(tree) {\n    this.tree = tree;\n    this.ctx = document.getElementById(\"treeCanvas\").getContext(\"2d\");\n  }\n\n  drawTree(node) {\n    if(node) {\n      this.drawNode(node);\n      if(node.leftChild) {\n        window.setTimeout(() => {\n          this.drawTree(node.leftChild);\n        }, 2000);\n      }\n      if (node.rightChild) {\n        window.setTimeout(() => {\n          this.drawTree(node.rightChild);\n        }, 3000);\n      }\n    }\n    return ;\n  }\n\n  drawNode(node) {\n    this.ctx.beginPath();\n    this.ctx.arc(node.x, node.y, NODE_RADIUS, 0, FULL_CIRCLE, true);\n    this.ctx.textAlign = \"center\";\n    this.ctx.textBaseline = \"middle\";\n    this.ctx.fillStyle = \"#f7b983\";\n    this.ctx.fill();\n    this.ctx.fillStyle = \"#050200\";\n    this.ctx.fillText(node.data.join(','), node.x, node.y);\n    this.ctx.stroke();\n    this.drawChildrenPath(node, this.ctx);\n  }\n\n  drawChildrenPath(node) {\n    if(node.leftChild !== null) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(node.x + LEFT_START, node.y + Y_START);\n      this.ctx.lineTo(node.x+ LEFT_OFFSET, node.y + Y_OFFSET);\n      this.ctx.stroke();\n    }\n    if(node.rightChild !== null) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(node.x+ RIGHT_START, node.y + Y_START);\n      this.ctx.lineTo(node.x+ RIGHT_OFFSET, node.y + Y_OFFSET);\n      this.ctx.stroke();\n    }\n  }\n}\n\nexport default TreeVis;\n","import TwoDVector from './vector.js';\nimport { LEFT_OFFSET, RIGHT_OFFSET, Y_OFFSET } from './tree_vis';\n\nclass KDNode {\n  constructor(data, parent = null, leftChild = null, rightChild = null, dim = 0) {\n    this.data = data;\n    this.parent = parent;\n    this.leftChild = leftChild;\n    this.rightChild = rightChild;\n    this.dim = dim;\n    this.x = 150;\n    this.y = 100;\n    this.velocity = new TwoDVector(0,0);\n  }\n\n  addLeftChild(node) {\n    this.leftChild = node;\n    node.parent = this;\n    node.dim = (this.dim + 1) % 2;\n    node.x = node.parent.x + LEFT_OFFSET;\n    node.y = node.parent.y + Y_OFFSET;\n  }\n\n  addRightChild(node) {\n    this.rightChild = node;\n    node.parent = this;\n    node.dim = (this.dim + 1) % 2;\n    node.x = node.parent.x + RIGHT_OFFSET;\n    node.y = node.parent.y + Y_OFFSET;\n  }\n}\n\nexport default KDNode;\n","class MaxHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  leftChild(i) {\n    return (2*i) + 1;\n  }\n\n  rightChild(i) {\n    return (2*i) + 2;\n  }\n\n  parent(i) {\n    return Math.floor((i-1)/2);\n  }\n\n  peek() {\n    return this.heap[0];\n  }\n\n  size() {\n    return this.heap.length;\n  }\n\n  insert(el) {\n    this.heap.push(el);\n    this._heapifyUp();\n  }\n\n  extract() {\n    // let result = this.heap[0];\n    let temp = this.heap[0];\n    this.heap[0] = this.heap[this.heap.length-1];\n    this.heap[this.heap.length-1] = temp;\n    let result = this.heap.pop();\n    this._heapifyDown();\n    return result;\n  }\n\n  _heapifyUp() {\n    let child = this.heap.length-1;\n    let parent = this.parent(child);\n    while(parent >= 0) {\n      if(this.heap[parent] < this.heap[child]) {\n        let temp = this.heap[child];\n        this.heap[child] = this.heap[parent];\n        this.heap[parent] = temp;\n        child = parent;\n        parent = this.parent(parent);\n      } else {\n        break;\n      }\n    }\n  }\n\n  _heapifyDown() {\n    let parent = 0;\n    let leftChild = this.leftChild(parent);\n    let rightChild = this.rightChild(parent);\n    while(rightChild <= this.heap.length-1) {\n      let child = this.heap[leftChild] >= this.heap[rightChild] ? leftChild : rightChild;\n      if(this.heap[parent] < this.heap[child]) {\n        let temp = this.heap[child];\n        this.heap[child] = this.heap[parent];\n        this.heap[parent] = temp;\n        parent = child;\n        leftChild = this.leftChild(parent);\n        rightChild = this.rightChild(parent);\n      } else {\n        break;\n      }\n    }\n  }\n}\n\nexport default MaxHeap;\n","export const inorderTraversal = root => {\n\n  if(root.leftChild !== null) {\n    inorderTraversal(root.leftChild);\n  }\n  // console.log(root);\n  if(root.rightChild !== null) {\n    inorderTraversal(root.rightChild);\n  }\n  return;\n};\n\nexport const sortByDimension = (list, dim) => {\n  return list.sort((pointA, pointB) => {\n    if(pointA[dim] < pointB[dim]) {\n      return -1;\n    } else if (pointA[dim] === pointB[dim]) {\n      return 0;\n    } else {\n      return 1;\n    }\n  });\n  // if (list.length % 2 === 0) {\n  //   return list[(list.length/2)-1];\n  // } else {\n  //   return list[Math.floor(list.length/2)];\n  // }\n};\n\nexport const getNextDim = (dim, totalDims) => {\n  return (dim + 1) % totalDims;\n};\n","import KDNode from './kd_node';\nimport MaxHeap from './heap.js';\nimport TwoDVector from './vector.js';\nimport { sortByDimension, getNextDim } from './tree_util';\n\nclass KDTree {\n  constructor(root = null, dims) {\n    this.root = root;\n    this.dims = dims;\n  }\n\n  buildTree(pointList) {\n    pointList.forEach((point) => {\n      this.assignPoint(point, this.root);\n    });\n  }\n\n  setRoot(point) {\n    this.root = new KDNode(point);\n  }\n\n  buildOptimalTree(pointList, dim = 0) {\n    if(pointList.length === 0) {\n      return pointList;\n    }\n    // console.log(pointList);\n    const sortedList = sortByDimension(pointList, dim);\n\n    let pivot;\n    let mid;\n    if (pointList.length % 2 === 0) {\n      mid = (pointList.length/2)-1;\n      pivot = pointList[mid];\n    } else {\n      mid = Math.floor(pointList.length/2);\n      pivot = pointList[mid];\n    }\n    // console.log(pivot);\n    this.assignPoint(pivot, this.root);\n    const leftPointList = sortedList.slice(0, mid);\n    const rightPointList = sortedList.slice(mid+1);\n    this.buildOptimalTree(leftPointList, getNextDim(dim, this.dims));\n    this.buildOptimalTree(rightPointList, getNextDim(dim, this.dims));\n  }\n\n  assignPoint(point, node) {\n    if (!node) {\n      return this.setRoot(point);\n    }\n    if(point[node.dim] <= node.data[node.dim]) {\n      if(node.leftChild === null){\n        node.addLeftChild(new KDNode(point));\n      } else {\n        this.assignPoint(point, node.leftChild);\n      }\n    } else {\n      // debugger\n      if(node.rightChild === null) {\n        node.addRightChild(new KDNode(point));\n      } else {\n        this.assignPoint(point, node.rightChild);\n      }\n    }\n  }\n\n  rangeSearch(node, bounds) {\n    let nodeList = [];\n    // debugger\n    if(node) {\n      if(node.data[0] >= bounds[0][0] && node.data[0] <= bounds[0][1] &&\n          node.data[1] >= bounds[1][0] && node.data[1] <= bounds[1][1]) {\n        nodeList.push(node);\n        nodeList = nodeList.concat(this.rangeSearch(node.leftChild, bounds));\n        nodeList = nodeList.concat(this.rangeSearch(node.rightChild, bounds));\n        return nodeList;\n      } else {\n        if(node.data[node.dim] > bounds[node.dim][1]) {\n          nodeList = nodeList.concat(this.rangeSearch(node.leftChild, bounds));\n          return nodeList;\n        } else if(node.data[node.dim] < bounds[node.dim][0]) {\n          nodeList = nodeList.concat(this.rangeSearch(node.rightChild, bounds));\n          return nodeList;\n        }\n      }\n    }\n    return nodeList;\n  }\n\n  getPoints(node) {\n    let points = [];\n    if (node) {\n      points.push(node);\n      points = points.concat(this.getPoints(node.leftChild));\n      points = points.concat(this.getPoints(node.rightChild));\n    }\n    return points;\n  }\n\n  kNearestNeigborsNaive(queryPoint, points, k=1) {\n    const champions = [[null, 1000000]];\n\n    for(let i = 0; i < points.length; i++) {\n      let distance = Math.sqrt((queryPoint[0] - points[i].data[0])**2 + (queryPoint[1] - points[i].data[1])**2);\n      console.log(distance, points[i]);\n      if(distance < champions[0][1]) {\n        champions.shift();\n        champions.unshift([points[i], distance]);\n      }\n    }\n    return champions;\n  }\n\n  kNearestNeigbors(queryPoint, node, champions, k=3, hash = {}) {\n\n    if (node) {\n      if(isNaN(node.data[0])){\n        debugger\n      }\n      let distance = this.euclideanDistance(queryPoint, node.data);\n      console.log(distance);\n      if(champions.size() < k) {\n        champions.insert(distance);\n        hash[distance] = node;\n        if(queryPoint[node.dim] <= node[node.dim]){\n          this.kNearestNeigbors(queryPoint, node.leftChild, champions, k, hash);\n          this.kNearestNeigbors(queryPoint, node.rightChild, champions, k, hash);\n        } else {\n          this.kNearestNeigbors(queryPoint, node.rightChild, champions, k, hash);\n          this.kNearestNeigbors(queryPoint, node.leftChild, champions, k, hash);\n        }\n      } else {\n        if(distance < champions.peek()) {\n          hash[distance] = node;\n          champions.extract();\n          champions.insert(distance);\n          this.kNearestNeigbors(queryPoint, node.leftChild, champions, k, hash);\n          this.kNearestNeigbors(queryPoint, node.rightChild, champions, k, hash);\n        } else {\n          return champions;\n        }\n      }\n      if(this.root === node) {\n        let results = [];\n        for(let i = 0; i < champions.size(); i++) {\n          results.push(hash[champions.heap[i]]);\n        }\n        debugger\n        return results;\n      }\n      return champions;\n    }\n  }\n\n  euclideanDistance(pointA, pointB) {\n    let dimValues = [];\n    for(let i = 0; i < pointA.length; i++) {\n      dimValues.push((pointA[i] - pointB[i])**2);\n    }\n    // console.log(dimValues);\n    let sum = dimValues.reduce((acc, currVal) => acc + currVal)\n    if(isNaN(Math.sqrt(sum))) {\n      debugger\n    }\n    return Math.sqrt(sum);\n  }\n\n  centerOfMass(node) {\n    // const nodes = this.getPoints(this.root);\n    const nodes = this.kNearestNeigbors(node.data, this.root, new MaxHeap(), 10);\n    // let cOfMass = [0, 0];\n    // console.log(nodes);\n    let cOfMass = null;\n    for(let i = 0; i < nodes.length; i++) {\n      if(node.data !== nodes[i].data) {\n        if(cOfMass === null) {\n          debugger\n          cOfMass = new TwoDVector(nodes[i].data[0], nodes[i].data[1]);\n        } else {\n          cOfMass.addVector(nodes[i].data);\n        }\n      }\n    }\n    debugger\n    cOfMass.divideVector(nodes.length-1);\n    return cOfMass.addVector(node.data).divideVector(100);\n  }\n\n  avoidCollision(node) {\n    let vector = new TwoDVector(0,0);\n    let nodes = this.getPoints(this.root);\n    debugger\n    for(let i = 0; i < nodes.length; i++) {\n      if(nodes[i].data !== node.data) {\n        let distance = this.euclideanDistance(nodes[i].data, node.data);\n        if(Math.abs(distance) < 100) {\n          vector.addVector(-distance);\n        }\n      }\n    }\n    return vector;\n  }\n\n  matchVelocity(node) {\n    let vector = null;\n    let nodes = this.kNearestNeigbors(node.data, this.root, new MaxHeap(), 10);\n    for(let i = 0; i < nodes.length; i++) {\n      if(nodes[i].data !== nodes.data) {\n        if(vector === null) {\n          vector = new TwoDVector(nodes[i].data[0], nodes[i].data[1]);\n        } else {\n          vector.addVector(nodes[i].velocity);\n        }\n      }\n    }\n    vector.divideVector(nodes.length-1);\n    return vector.addVector(node.velocity).divideVector(8);\n  }\n\n  bounding_box(node) {\n    const xMin = 0, xMax = 600, yMin = 0, yMax = 600;\n    let vector = new TwoDVector(0,0);\n    if(node.data[0] < xMin) {\n      vector.x = 10;\n    } else if(node.data[0] > xMax) {\n      vector.x = -10;\n    } else if(node.data[1] < yMin) {\n      vector.y = 10;\n    } else if(node.data[1] > yMin) {\n      vector.y = -10;\n    }\n    return vector;\n  }\n\n  step() {\n    let nodes = this.getPoints(this.root);\n    let v1, v2, v3, v4;\n    for(let i = 0; i < nodes.length; i++) {\n      v1 = this.centerOfMass(nodes[i]);\n      v2 = this.avoidCollision(nodes[i]);\n      v3 = this.matchVelocity(nodes[i]);\n      v4 = this.bounding_box(nodes[i]);\n      nodes[i].velocity.addVector(v1).addVector(v2).addVector(v3).addVector(v4);\n      nodes[i].data[0] += nodes[i].velocity.x;\n      nodes[i].data[1] += nodes[i].velocity.y;\n    }\n  }\n}\n\nexport default KDTree;\n","import {\n  FULL_CIRCLE\n} from './tree_vis';\n\nclass TwoDVis {\n  constructor(tree) {\n    this.tree = tree;\n    this.ctx = document.getElementById(\"2DCanvas\").getContext(\"2d\");\n    this.width = 620;\n    this.height = 620;\n    this.ctx.beginPath();\n    this.ctx.strokeRect(0, 0, 600, 600);\n    this.drawAxis();\n  }\n\n  drawAxis() {\n    for(let i = 1; i < 11; i++) {\n      this.ctx.beginPath();\n      // this.ctx.moveTo(i*60, 610);\n      // this.ctx.stroke();\n      this.ctx.textAlign = \"center\";\n      this.ctx.textBaseline = \"middle\";\n      this.ctx.fillText(i, i*60, 610);\n      this.ctx.fillText(i, 610, 600- i*60);\n    }\n  }\n\n  drawPoint(node) {\n    this.ctx.beginPath();\n    this.ctx.arc(node.data[0]*60, 600 - node.data[1]*60, 4, 0, FULL_CIRCLE, true);\n    this.ctx.fill();\n  }\n\n  drawPartition(node) {\n    const path = this.getPathToRoot(node);\n    const { xBounds, yBounds } = this.findBoundaries(path);\n    this.ctx.strokeRect(xBounds[0], yBounds[0], xBounds[1]-xBounds[0], yBounds[1]-yBounds[0]);\n  }\n\n  getPathToRoot(node) {\n    const path = [node];\n    if(node) {\n      while(node.parent !== null) {\n        path.push(node.parent)\n        node = node.parent;\n      }\n    }\n    return path.reverse();\n  }\n\n  findBoundaries(path) {\n    const xBounds = [0, 600];\n    const yBounds = [0, 600];\n    for(let i = 0; i < path.length; i++) {\n      if(path[i].leftChild === path[i+1]) { //left child\n        if(path[i].dim === 0) {\n          xBounds[1] = path[i].data[0] * 60;\n        } else {\n          yBounds[0] = 600 - path[i].data[1] * 60;\n        }\n      } else { //right child\n        if(path[i].dim === 0) {\n          xBounds[0] = path[i].data[0] * 60;\n        } else {\n          yBounds[1] = 600 - path[i].data[1] * 60;\n        }\n      }\n    }\n    return { xBounds,yBounds };\n  }\n\n  drawVis(node) {\n    if(node) {\n      this.drawPoint(node);\n      this.drawPartition(node);\n      if(node.leftChild) {\n        window.setTimeout(() => {\n          this.drawVis(node.leftChild);\n        }, 2000);\n      }\n      if (node.rightChild) {\n        window.setTimeout(() => {\n          this.drawVis(node.rightChild);\n        }, 3000);\n      }\n    }\n  }\n}\n\nexport default TwoDVis;\n","import {\n  FULL_CIRCLE\n} from './tree_vis';\n\nclass BoidVis {\n  constructor(tree) {\n    this.tree = tree;\n    this.ctx = document.getElementById(\"boidCanvas\").getContext(\"2d\");\n    this.width = 600;\n    this.height = 600;\n    this.ctx.beginPath();\n    this.ctx.strokeRect(0, 0, 600, 600);\n    window.setInterval(() => {\n      console.log('going');\n      this.drawVis();\n    }, 1000);\n  }\n\n  drawVis() {\n    let nodes = this.tree.getPoints(this.tree.root);\n    for(let i = 0; i < nodes.length; i++) {\n      this.drawPoint(nodes[i]);\n    }\n    this.tree.step();\n  }\n\n  drawPoint(node) {\n    this.ctx.beginPath();\n    this.ctx.arc(node.data[0], 600 - node.data[1], 2, 0, FULL_CIRCLE, true);\n    this.ctx.fill();\n  }\n\n\n}\n\nexport default BoidVis;\n","import KDTree from './kd_tree';\nimport KDNode from './kd_node';\nimport TreeVis from './tree_vis';\nimport TwoDVis from './two_d_vis';\nimport MaxHeap from './heap';\nimport BoidVis from './boid_vis';\nimport { setScene } from './three_d_vis';\nimport { inorderTraversal, findAxisMedian } from './tree_util';\ndocument.addEventListener('DOMContentLoaded', () => {\n  const threedPointList = [\n    [8,1,1],\n    [6,6,2],\n    [2,6,4],\n    [2,7,1],\n    [9,8,8],\n    [5,7,1],\n    [5,6,3]\n  ];\n\n  const twodPointList = [\n    [8,1],\n    [6,6],\n    [2,6],\n    [2,7],\n    [9,8],\n    [5,7],\n    [5,6],\n    [1,3],\n    [4,2],\n    [7,5],\n    [12,7],\n  ];\n  // console.log(pointList);\n\n  const tree = new KDTree(null, 2);\n  tree.buildOptimalTree(twodPointList);\n  console.log(tree.getPoints(tree.root));\n  const treeVis = new TreeVis(tree);\n  treeVis.drawTree(tree.root);\n  const twoDVis = new TwoDVis(tree);\n  twoDVis.drawVis(tree.root);\n  // setScene();\n  // console.\n  // console.log(tree.rangeSearch(tree.root, [[1, 4], [1, 6]]));\n  // console.log(tree.kNearestNeigbors([2,5], tree.root, new MaxHeap(), 10));\n  // console.log(tree.kNearestNeigbors([2,7], tree.root, new MaxHeap(), 10));\n  // const heap = new MaxHeap();\n  // heap.insert(1);\n  // heap.insert(5);\n  // heap.insert(3);\n  // heap.insert(9);\n  // heap.insert(11);\n  // heap.insert(7);\n  // heap.insert(2);\n  const boidVis = new BoidVis(tree);\n\n});\n"],"sourceRoot":""}